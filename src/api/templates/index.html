<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insights Flow Agent</title>
    <!-- Load Plotly.js FIRST -->
    <script src='https://cdn.plot.ly/plotly-2.32.0.min.js'></script>
    <!-- Include Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        #chat-log { height: calc(100vh - 150px); overflow-y: auto; overflow-x: visible; /* Adjust height & allow horizontal overflow for tooltips */ }
        /* Style for Plotly chart container */
        .visualization-container { overflow: visible; /* Allow tooltips to overflow */ }
        .visualization-container .plotly-graph-div { margin: auto; }
        /* Style for code blocks */
        pre code { display: block; white-space: pre-wrap; word-wrap: break-word; }
        /* Custom scrollbar */
        #chat-log::-webkit-scrollbar { width: 8px; }
        #chat-log::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px;}
        #chat-log::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px;}
        #chat-log::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        /* Tab styling */
        .tab-button.active { border-color: #4f46e5; color: #4f46e5; background-color: #eef2ff; }
        .tab-content { display: none; overflow: visible; /* Allow tooltips to overflow tabs */ }
        .tab-content.active { display: block; }
        /* Ensure table styles apply */
        .data-table table { min-width: 100%; border-collapse: collapse; } /* Added collapse */
        .data-table th { background-color: #f9fafb; padding: 8px 12px; text-align: left; font-weight: 500; color: #6b7280; border-bottom: 1px solid #e5e7eb;}
        .data-table td { padding: 8px 12px; border-bottom: 1px solid #e5e7eb; }
        .data-table tr:last-child td { border-bottom: none; } /* Remove border from last row */
        /* Style for copy/download buttons */
        .action-button {
            background-color: #e5e7eb; /* gray-200 */
            color: #374151; /* gray-700 */
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.75rem; /* text-xs */
            border: 1px solid #d1d5db; /* gray-300 */
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 8px; /* Add some space above */
            display: inline-block; /* Align properly */
        }
        .action-button:hover { background-color: #d1d5db; /* gray-300 */ }
        .action-button:active { background-color: #9ca3af; /* gray-400 */ }
        /* Allow agent result bubbles (containing charts/tabs) to overflow */
        .agent-result-bubble { overflow: visible; }
        /* Try to lift Plotly tooltips above other elements */
        .hovertext { z-index: 9999 !important; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col h-screen">

    <header class="bg-white shadow-sm p-4">
        <h1 class="text-2xl font-bold text-gray-700 text-center">Insights Flow Agent</h1>
    </header>

    <!-- Chat Log Area -->
    <div id="chat-log" class="flex-grow overflow-y-auto p-4 space-y-4 bg-white">
         <!-- Messages will be appended here -->
    </div>

    <!-- Input Area -->
    <footer class="p-4 bg-white border-t border-gray-200">
        <form id="query-form" class="flex items-center gap-4">
            <div class="flex-grow">
                 <input type="hidden" id="project-id" name="project-id" value="0d9e2c6f-5e1b-44ba-939f-32b584161b7b">
                 <textarea id="query-text" name="query-text" required rows="1" placeholder="Enter your query..."
                           class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm resize-none"></textarea>
            </div>
            <button type="submit"
                    class="inline-flex items-center px-4 py-2 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500">
                Send
            </button>
        </form>
         <!-- Clarification response area (initially hidden) - NEUTRAL STYLING -->
         <div id="clarification-section" class="mt-4 p-4 border border-blue-300 bg-blue-50 rounded-md" style="display: none;">
             <h3 class="text-lg font-medium text-blue-800 mb-2">Clarification Needed:</h3>
             <div id="clarification-inputs" class="space-y-3">
                 <!-- Clarification textareas will be added here by JS -->
             </div>
             <form id="clarification-form" class="mt-4">
                 <button type="submit"
                         class="w-full inline-flex justify-center py-2 px-4 border border-transparent shadow-sm text-sm font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
                     Submit Answers & Re-Analyze
                 </button>
             </form>
         </div>
    </footer>

    <script>
        const queryForm = document.getElementById('query-form');
        const queryTextarea = document.getElementById('query-text');
        const chatLog = document.getElementById('chat-log');
        const clarificationSection = document.getElementById('clarification-section');
        const clarificationForm = document.getElementById('clarification-form');
        const clarificationInputsDiv = document.getElementById('clarification-inputs');

        let currentQuery = '';
        let currentProjectId = '';
        let messageCounter = 0; // Counter for unique IDs

        // Function to add a message bubble to the chat log
        function addMessageBubble(sender, contentElementOrText) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('p-3', 'rounded-lg', 'max-w-3xl', 'text-sm', 'mb-4');

            if (sender === 'User') {
                messageDiv.classList.add('bg-blue-100', 'text-blue-800', 'ml-auto');
                messageDiv.innerHTML = `<p class="font-semibold mb-1">User:</p><p>${escapeHtml(contentElementOrText)}</p>`;
            } else { // Agent
                messageDiv.classList.add('bg-gray-100', 'text-gray-800', 'mr-auto');
                messageDiv.innerHTML = `<p class="font-semibold mb-1">Agent:</p>`;
                if (typeof contentElementOrText === 'string') {
                    const textP = document.createElement('p');
                    textP.textContent = contentElementOrText;
                    messageDiv.appendChild(textP);
                } else {
                     messageDiv.appendChild(contentElementOrText); // Append the element (e.g., tab container or loading indicator)
                     messageDiv.classList.add('agent-result-bubble'); // Add specific class for overflow style
                }
            }

            chatLog.appendChild(messageDiv);
            chatLog.scrollTop = chatLog.scrollHeight;
            return messageDiv;
        }

        // Function to add loading indicator
        function showLoadingIndicator() {
             if (document.getElementById('loading-indicator')) return;
             const loadingContent = document.createElement('p');
             loadingContent.classList.add('italic', 'text-gray-600');
             loadingContent.textContent = 'Analyzing...';
             const loadingBubble = addMessageBubble('Agent', loadingContent);
             loadingBubble.id = 'loading-indicator';
        }

        // Function to remove loading indicator
        function hideLoadingIndicator() {
            const indicator = document.getElementById('loading-indicator');
            if (indicator) indicator.remove();
        }

        // Function to extract Plotly data from HTML string
        function extractPlotlyData(htmlString) {
            console.log("Attempting to extract Plotly data..."); // DEBUG
            if (!htmlString) {
                console.log("Input HTML string is null or empty."); // DEBUG
                return null;
            }
            // CORRECTED Regex: Allows optional brace before semicolon
            const regex = /Plotly\.newPlot\(\s*['"]([^'"]+)['"],\s*(\[.*?\]),\s*(\{.*?\})\s*(?:,\s*(\{.*?\})\s*)?\s*\)\s*\}?\s*;/s;
            const plotCallMatch = htmlString.match(regex);
            console.log("Regex match result:", plotCallMatch ? "Found" : "Not Found"); // DEBUG

            if (plotCallMatch) {
                const divId = plotCallMatch[1];
                const dataStr = plotCallMatch[2];
                const layoutStr = plotCallMatch[3];
                const configStr = plotCallMatch[4];

                console.log("Regex matched. Div ID:", divId); // DEBUG

                try {
                    console.log("Attempting to parse Plotly data..."); // DEBUG
                    const plotData = new Function(`return ${dataStr}`)();
                    console.log("Parsed Plotly data successfully."); // DEBUG

                    console.log("Attempting to parse Plotly layout..."); // DEBUG
                    const plotLayout = new Function(`return ${layoutStr}`)();
                    console.log("Parsed Plotly layout successfully."); // DEBUG

                    let plotConfig = {"responsive": true};
                    if (configStr) {
                        try {
                            console.log("Attempting to parse Plotly config..."); // DEBUG
                            plotConfig = new Function(`return ${configStr}`)();
                            console.log("Parsed Plotly config successfully."); // DEBUG
                        } catch(configError) {
                             console.warn("Failed to parse Plotly config, using default. Error:", configError); // DEBUG
                             plotConfig = {"responsive": true}; // Fallback to default
                        }
                    } else {
                         console.log("No Plotly config found, using default."); // DEBUG
                    }

                    return {
                        divId: divId,
                        data: plotData,
                        layout: plotLayout,
                        config: plotConfig
                    };
                } catch (e) {
                    console.error("Failed to parse Plotly JSON components using Function constructor:", e);
                    return null;
                }
            }
            console.warn("Could not find valid Plotly.newPlot call signature in visualization_html");
            return null;
        }


        // Function to create and manage tabs - REVISED FOR EXPLICIT PLOTLY CALL
        function createTabs(data, messageId) {
            const tabContainer = document.createElement('div');
            const tabButtons = document.createElement('div');
            tabButtons.classList.add('border-b', 'border-gray-200', 'mb-3', '-mt-2');
            const tabContentContainer = document.createElement('div');

            const tabs = [];
            const plotlyInfo = extractPlotlyData(data.visualization_html); // Extract info first
            const hasSummary = !!data.visualization_summary; // Check if summary exists
            const hasAssumptions = data.assumptions && Array.isArray(data.assumptions) && data.assumptions.length > 0; // Check for assumptions

            // Determine tabs needed
            if (plotlyInfo) tabs.push({ id: 'chart', label: 'Chart' });
            if (data.data_table_html) tabs.push({ id: 'data', label: 'Data' });
            if (data.sql_query) tabs.push({ id: 'sql', label: 'SQL' });
            if (hasAssumptions) tabs.push({ id: 'assumptions', label: 'Assumptions' }); // Add Assumptions tab

            // Handle case where only summary exists (and maybe assumptions)
            if (hasSummary && !plotlyInfo && !data.data_table_html && !data.sql_query && !hasAssumptions) {
                 tabs.push({ id: 'summary-only', label: 'Summary'});
            }

            if (tabs.length === 0 && !hasSummary) {
                const noDataP = document.createElement('p');
                noDataP.textContent = data.data_summary || "Analysis complete, but no specific outputs generated.";
                noDataP.classList.add('text-sm', 'text-gray-700');
                return { element: noDataP, plotlyInfo: null }; // Return null for plotlyInfo
            }

            tabs.forEach((tab, index) => {
                const button = document.createElement('button');
                button.textContent = tab.label;
                button.classList.add('tab-button', 'py-2', 'px-4', 'text-sm', 'font-medium', 'border-b-2', 'border-transparent', 'text-gray-500', 'hover:border-gray-300', 'hover:text-gray-700');
                button.dataset.tabTarget = `${messageId}-${tab.id}`;

                const content = document.createElement('div');
                content.id = `${messageId}-${tab.id}`;
                content.classList.add('tab-content', 'pt-2');

                if (index === 0) {
                    button.classList.add('active');
                    content.classList.add('active');
                }

                // Populate Content
                // if (tab.id === 'summary') { // REMOVED Summary tab population
                //     content.innerHTML = `<p class="text-sm text-gray-700">${escapeHtml(data.visualization_summary)}</p>`;
                // } else
                if (tab.id === 'chart') {
                    // Create chart container and placeholder div
                    const chartContainer = document.createElement('div');
                    chartContainer.classList.add('visualization-container', 'bg-white', 'p-1', 'rounded-md', 'border', 'border-gray-200', 'min-h-[400px]', 'flex', 'items-center', 'justify-center');
                    const chartDiv = document.createElement('div');
                    chartDiv.id = plotlyInfo.divId; // Use the extracted ID
                    chartDiv.classList.add('plotly-graph-div');
                    chartDiv.style.height = '100%';
                    chartDiv.style.width = '100%';
                    chartContainer.appendChild(chartDiv);
                    content.appendChild(chartContainer); // Add chart container first

                    // If summary exists, add it below the chart container
                    if (hasSummary) {
                        const summaryDiv = document.createElement('div');
                        summaryDiv.classList.add('mt-3', 'pt-3', 'border-t', 'border-gray-200'); // Add some spacing and separator
                        summaryDiv.innerHTML = `<p class="text-sm text-gray-700">${escapeHtml(data.visualization_summary)}</p>`;
                        content.appendChild(summaryDiv);
                    }
                } else if (tab.id === 'summary-only') { // Handle case where only summary exists
                     content.innerHTML = `<p class="text-sm text-gray-700">${escapeHtml(data.visualization_summary)}</p>`;
                } else if (tab.id === 'assumptions') {
                    const assumptionsList = document.createElement('ul');
                    assumptionsList.classList.add('list-disc', 'list-inside', 'space-y-1', 'text-sm', 'text-gray-700');
                    data.assumptions.forEach(assumption => {
                        const listItem = document.createElement('li');
                        listItem.textContent = assumption;
                        assumptionsList.appendChild(listItem);
                    });
                    content.appendChild(assumptionsList);
                } else if (tab.id === 'data') {
                    // Add a container for scrollability and the button
                    const dataContainer = document.createElement('div');
                    const tableScrollDiv = document.createElement('div');
                    tableScrollDiv.classList.add('data-table', 'overflow-auto', 'max-h-96', 'border', 'border-gray-200', 'rounded-md', 'text-xs'); // Added max-h-96 and border/rounded
                    tableScrollDiv.innerHTML = data.data_table_html || '<p class="p-2">No data table available.</p>';
                    dataContainer.appendChild(tableScrollDiv);

                    // Add Download CSV button if data exists
                    if (data.data_table_html) {
                        const downloadButton = document.createElement('button');
                        downloadButton.textContent = 'Download CSV';
                        downloadButton.classList.add('action-button');
                        downloadButton.onclick = () => downloadCsv(tableScrollDiv.querySelector('table'), `query_result_${messageId}.csv`);
                        dataContainer.appendChild(downloadButton);
                    }
                    content.appendChild(dataContainer);

                } else if (tab.id === 'sql') {
                    // Add a container for the code and button
                    const sqlContainer = document.createElement('div');
                    const preBlock = document.createElement('pre');
                    preBlock.classList.add('bg-gray-800', 'text-white', 'p-3', 'rounded-md', 'overflow-x-auto', 'text-xs');
                    const codeBlock = document.createElement('code');
                    codeBlock.classList.add('language-sql');
                    codeBlock.textContent = data.sql_query || 'No SQL query available.'; // Use textContent for raw text
                    preBlock.appendChild(codeBlock);
                    sqlContainer.appendChild(preBlock);

                    // Add Copy SQL button if SQL exists
                    if (data.sql_query) {
                        const copyButton = document.createElement('button');
                        copyButton.textContent = 'Copy SQL';
                        copyButton.classList.add('action-button');
                        copyButton.onclick = (event) => copySqlToClipboard(codeBlock.textContent, event.target);
                        sqlContainer.appendChild(copyButton);
                    }
                    content.appendChild(sqlContainer);
                }

                tabButtons.appendChild(button);
                tabContentContainer.appendChild(content);

                // Add click listener for tab switching
                button.addEventListener('click', () => {
                    tabContainer.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    tabContainer.querySelectorAll('.tab-content').forEach(pane => pane.classList.remove('active'));
                    button.classList.add('active');
                    content.classList.add('active');
                    // Attempt to resize Plotly chart if it's the chart tab and already rendered
                    if (tab.id === 'chart') {
                        const chartDiv = content.querySelector(`#${plotlyInfo.divId}`);
                        // Check if the plot exists by looking for a specific class Plotly adds
                        if (chartDiv && chartDiv.classList.contains('js-plotly-plot') && typeof Plotly !== 'undefined') {
                             try {
                                 console.log("Resizing existing Plotly chart:", plotlyInfo.divId); // DEBUG
                                 setTimeout(() => Plotly.Plots.resize(chartDiv), 0);
                             } catch (e) { console.warn("Plotly resize failed:", e); }
                        } else {
                             console.log("Chart not yet rendered or Plotly library missing on resize attempt."); // DEBUG
                        }
                    }
                });
            });

            tabContainer.appendChild(tabButtons);
            tabContainer.appendChild(tabContentContainer);
            // Return the container element AND the extracted plotly info
            return { element: tabContainer, plotlyInfo: plotlyInfo };
        }


        // Function to handle analysis request
        async function handleAnalysisRequest(projectId, queryText, clarifications = null) {
            const submitButton = queryForm.querySelector('button[type="submit"]');
            const clarificationSubmitButton = clarificationForm.querySelector('button[type="submit"]');

            if (submitButton) submitButton.disabled = true;
            if (clarificationSubmitButton) clarificationSubmitButton.disabled = true;
            clarificationSection.style.display = 'none';
            // clarificationInputsDiv.innerHTML = ''; // No longer needed

            showLoadingIndicator();

            if (!clarifications) { // This check might still be relevant if we re-introduce clarifications later
                currentQuery = queryText;
                currentProjectId = projectId;
            }

            try {
                const response = await fetch('/analyze', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
                    body: JSON.stringify({
                        project_id: projectId,
                        query: queryText,
                        clarifications: clarifications
                    })
                });

                hideLoadingIndicator();

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error ${response.status}: ${errorText}`);
                }

                const data = await response.json();
                console.log("Received data from /analyze:", JSON.stringify(data, null, 2));

                // Handle successful response with potential results
                if (data.status === 'success') {
                    messageCounter++;
                    const tabResult = createTabs(data, `msg-${messageCounter}`); // Get element and plotly info

                    if (tabResult && tabResult.element) {
                        const agentBubble = addMessageBubble('Agent', tabResult.element); // Add bubble with tab container

                        // If plotly info exists, try to render the chart AFTER the bubble is in the DOM
                        if (tabResult.plotlyInfo) {
                            // Use setTimeout to allow DOM update before finding the div
                            setTimeout(() => {
                                const chartDiv = agentBubble.querySelector(`#${tabResult.plotlyInfo.divId}`);
                                if (chartDiv && typeof Plotly !== 'undefined') {
                                    try {
                                        console.log("Attempting Plotly.newPlot for:", tabResult.plotlyInfo.divId); // DEBUG
                                        Plotly.newPlot(
                                            tabResult.plotlyInfo.divId,
                                            tabResult.plotlyInfo.data,
                                            tabResult.plotlyInfo.layout,
                                            tabResult.plotlyInfo.config
                                        );
                                        console.log("Plotly.newPlot called successfully."); // DEBUG
                                    } catch (e) {
                                        console.error("Plotly.newPlot failed:", e);
                                        chartDiv.innerHTML = `<p class="text-red-600">Error rendering chart: ${e.message}</p>`;
                                    }
                                } else if (!chartDiv) {
                                     console.error("Chart div with ID not found after adding message:", tabResult.plotlyInfo.divId);
                                } else {
                                     console.error("Plotly library not loaded.");
                                }
                            }, 50); // Increased delay slightly
                        }
                    } else {
                         addMessageBubble('Agent', 'Failed to generate result display.');
                    }

                }
                // Handle Errors (Keep this part)
                 else if (data.status === 'error' && data.error_message) {
                     addMessageBubble('Agent', `Error: ${escapeHtml(data.error_message)}`);
                 }
                 // Removed clarification_needed block
                 else if (data.status !== 'success') { // Catch other non-success statuses
                     addMessageBubble('Agent', 'Received an unexpected response or no output generated.');
                 }

             } catch (error) {
                hideLoadingIndicator();
                console.error('Error fetching analysis:', error);
                 addMessageBubble('Agent', `Failed to get analysis: ${error.message}`);
             } finally {
                 if (submitButton) submitButton.disabled = false;
                 if (clarificationSubmitButton) clarificationSubmitButton.disabled = false;
             }
         }

         // CORRECTED VERSION
         function escapeHtml(unsafe) {
             if (typeof unsafe !== 'string') {
                 return unsafe; // Return non-strings as-is
             }
             // Ensure proper escaping for HTML display
             return unsafe
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;") // Use the correct HTML entity
                  .replace(/'/g, "&#039;");
         }
         
         // Initial query submission
        queryForm.addEventListener('submit', (event) => {
            event.preventDefault();
            const projectId = document.getElementById('project-id').value;
            const queryText = queryTextarea.value.trim();
            if (!projectId || !queryText) {
                alert('Please enter both Project ID and Query.');
                return;
            }
            addMessageBubble('User', queryText);
            queryTextarea.value = '';
            handleAnalysisRequest(projectId, queryText, null);
        });

        // Clarification submission - REMOVED
        // clarificationForm.addEventListener('submit', (event) => { ... });

        // Auto-resize textarea
        queryTextarea.addEventListener('input', () => {
            queryTextarea.style.height = 'auto';
            queryTextarea.style.height = (queryTextarea.scrollHeight) + 'px';
        });
        queryTextarea.addEventListener('focus', () => {
             queryTextarea.style.height = 'auto';
             queryTextarea.style.height = (queryTextarea.scrollHeight) + 'px';
         });

         // --- Helper Functions for Download/Copy ---

         function downloadCsv(tableElement, filename) {
             if (!tableElement) {
                 console.error("No table element found for CSV download.");
                 return;
             }
             let csv = [];
             const rows = tableElement.querySelectorAll("tr");

             // Header row
             const headerCells = rows[0].querySelectorAll("th");
             let header = [];
             headerCells.forEach(cell => header.push(`"${cell.textContent.replace(/"/g, '""')}"`)); // Quote and escape quotes
             csv.push(header.join(","));

             // Data rows
             for (let i = 1; i < rows.length; i++) {
                 const cells = rows[i].querySelectorAll("td");
                 let row = [];
                 cells.forEach(cell => row.push(`"${cell.textContent.replace(/"/g, '""')}"`)); // Quote and escape quotes
                 csv.push(row.join(","));
             }

             // Create CSV file and trigger download
             const csvContent = "data:text/csv;charset=utf-8," + csv.join("\n");
             const encodedUri = encodeURI(csvContent);
             const link = document.createElement("a");
             link.setAttribute("href", encodedUri);
             link.setAttribute("download", filename);
             document.body.appendChild(link); // Required for Firefox
             link.click();
             document.body.removeChild(link);
         }

         function copySqlToClipboard(sqlText, buttonElement) {
             if (!navigator.clipboard) {
                 alert('Clipboard API not available in this browser.');
                 return;
             }
             navigator.clipboard.writeText(sqlText).then(() => {
                 const originalText = buttonElement.textContent;
                 buttonElement.textContent = 'Copied!';
                 setTimeout(() => { buttonElement.textContent = originalText; }, 1500); // Revert after 1.5s
             }).catch(err => {
                 console.error('Failed to copy SQL: ', err);
                 alert('Failed to copy SQL to clipboard.');
             });
         }

     </script>
 </body>
 </html>
